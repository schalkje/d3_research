<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Adapter Layouts - Test Page</title>
    
    <!-- Standard CSS -->
    <link rel="stylesheet" href="../../dashboard/flowdash.css">
    
    <!-- Optional demo-specific CSS -->
    <link rel="stylesheet" href="css/demo.css" if-exists>
    
    <!-- Required Libraries -->
    <script src="../../dashboard/libs/d3.min.js"></script>
    <script src="../../dashboard/libs/d3-shape.min.js"></script>
    <script src="../../dashboard/libs/d3-dag.iife.min.js"></script>
</head>
<body>
    <!-- Demo Header -->
    <header class="demo-header">
        <h1>Nodes</h1>
        <h2>Multiple Adapter Layouts Test</h2>
        <p class="demo-description">Comprehensive test page showcasing all 5 adapter layout arrangements and different modes</p>
        
        <!-- Demo Controls -->
        <div class="demo-controls">
            <button id="settingsBtn" type="button">Settings</button>
            <button id="updateBtn" onclick="updateDemo()">Update</button>
            <button id="resetBtn" onclick="resetDemo()">Reset</button>
            <button id="testBtn" onclick="runTests()">Run Tests</button>
            <button id="cycleBtn" onclick="cycleLayouts()">Cycle Layouts</button>
        </div>
    </header>

    <!-- Demo Container -->
    <!-- Settings Panel -->
    <section class="settings-panel">
        <div class="settings-row">
            <div class="settings-group">
                <label class="settings-title">Variation</label>
                <select id="variationSelect">
                    <option value="default">Default</option>
                    <option value="allFull">All Full Arrangements</option>
                    <option value="twoNode">Two-Node Modes</option>
                    <option value="singleNode">Single Node Mode</option>
                    <option value="mixedDisplay">Mixed Display Modes</option>
                    <option value="comprehensive">Comprehensive Grid</option>
                </select>
            </div>
            <div class="settings-group is-toggles">
                <label class="settings-title">Toggles</label>
                <div class="settings-toggles">
                    <label><input type="checkbox" id="chkZoomToRoot"> Zoom to root</label>
                    <label><input type="checkbox" id="chkShowBoundingBox"> Show bounding box</label>
                    <label><input type="checkbox" id="chkShowCenterMark"> Center mark</label>
                    <label><input type="checkbox" id="chkShowConnectionPoints"> Connection points</label>
                    <label><input type="checkbox" id="chkShowGhostlines"> Ghostlines</label>
                    <label><input type="checkbox" id="chkCurved"> Curved edges</label>
                    <label><input type="checkbox" id="chkShowEdges" checked> Show edges</label>
                </div>
            </div>
            <div class="settings-group">
                <label class="settings-title">Edges</label>
                <div class="settings-inline">
                    <label>Curve margin <input type="number" step="0.05" min="0" max="0.8" id="numCurveMargin" style="width:80px"></label>
                </div>
            </div>
        </div>
        <div class="settings-row">
            <div class="settings-group">
                <label class="settings-title">Selector</label>
                <div class="settings-inline">
                    <label>Incoming <input type="number" min="0" id="numSelectorIn" style="width:70px"></label>
                    <label>Outgoing <input type="number" min="0" id="numSelectorOut" style="width:70px"></label>
                </div>
            </div>
            <div class="settings-group">
                <label class="settings-title">Node spacing</label>
                <div class="settings-inline">
                    <label>H <input type="number" min="0" id="numNodeSpacingH" style="width:70px"></label>
                    <label>V <input type="number" min="0" id="numNodeSpacingV" style="width:70px"></label>
                </div>
            </div>
            <div class="settings-group">
                <label class="settings-title">Container margin</label>
                <div class="settings-inline">
                    <label>T <input type="number" min="0" id="numMarginTop" style="width:60px"></label>
                    <label>R <input type="number" min="0" id="numMarginRight" style="width:60px"></label>
                    <label>B <input type="number" min="0" id="numMarginBottom" style="width:60px"></label>
                    <label>L <input type="number" min="0" id="numMarginLeft" style="width:60px"></label>
                </div>
            </div>
            <div class="settings-actions">
                <button id="rebuildBtn" type="button">Rebuild</button>
            </div>
        </div>
    </section>

    <div class="demo-container">
        <svg id="graph" class="canvas"></svg>
    </div>

    <!-- Layout Information Panel -->
    <div class="layout-info-panel">
        <h3>Current Layouts Displayed</h3>
        <div id="layoutDetails" class="layout-details">
            <!-- Will be populated by JavaScript -->
        </div>
    </div>

    <!-- Demo Information -->
    <footer class="demo-info">
        <div class="demo-metadata">
            <p><strong>Node Type:</strong> Multiple Adapters</p>
            <p><strong>Layouts:</strong> All 5 arrangements (1, 2, 3, 4, 5)</p>
            <p><strong>Modes:</strong> Full, staging-archive, staging-transform, archive-only</p>
            <p><strong>Test Status:</strong> <span id="testStatus">Ready for Testing</span></p>
        </div>
    </footer>

    <script type="module">
        // Import demo data
        import { multipleLayoutsData, layoutVariations } from './js/graphData.js';
        import flowDashboard from '../../dashboard/js/index.js';

        let currentDataIndex = 0;
        let flowdash;
        let currentVariationKey = 'default';

        // Initialize dashboard with first layout
        function getSettingsFromUI(baseSettings) {
            const s = { ...(baseSettings || {}) };
            s.zoomToRoot = document.getElementById('chkZoomToRoot').checked;
            s.showBoundingBox = document.getElementById('chkShowBoundingBox').checked;
            s.showCenterMark = document.getElementById('chkShowCenterMark').checked;
            s.showConnectionPoints = document.getElementById('chkShowConnectionPoints').checked;
            s.showGhostlines = document.getElementById('chkShowGhostlines').checked;
            s.curved = document.getElementById('chkCurved').checked;
            s.showEdges = document.getElementById('chkShowEdges').checked;
            const curveMargin = parseFloat(document.getElementById('numCurveMargin').value);
            if (!Number.isNaN(curveMargin)) s.curveMargin = curveMargin;
            s.selector = s.selector || {};
            const inVal = parseInt(document.getElementById('numSelectorIn').value, 10);
            const outVal = parseInt(document.getElementById('numSelectorOut').value, 10);
            if (!Number.isNaN(inVal)) s.selector.incomming = inVal;
            if (!Number.isNaN(outVal)) s.selector.outgoing = outVal;
            s.nodeSpacing = s.nodeSpacing || {};
            const h = parseInt(document.getElementById('numNodeSpacingH').value, 10);
            const v = parseInt(document.getElementById('numNodeSpacingV').value, 10);
            if (!Number.isNaN(h)) s.nodeSpacing.horizontal = h;
            if (!Number.isNaN(v)) s.nodeSpacing.vertical = v;
            s.containerMargin = s.containerMargin || {};
            const mt = parseInt(document.getElementById('numMarginTop').value, 10);
            const mr = parseInt(document.getElementById('numMarginRight').value, 10);
            const mb = parseInt(document.getElementById('numMarginBottom').value, 10);
            const ml = parseInt(document.getElementById('numMarginLeft').value, 10);
            if (!Number.isNaN(mt)) s.containerMargin.top = mt;
            if (!Number.isNaN(mr)) s.containerMargin.right = mr;
            if (!Number.isNaN(mb)) s.containerMargin.bottom = mb;
            if (!Number.isNaN(ml)) s.containerMargin.left = ml;
            return s;
        }

        function setUIFromSettings(settings) {
            const s = settings || {};
            const get = (obj, key, def) => obj && obj[key] !== undefined ? obj[key] : def;
            document.getElementById('chkZoomToRoot').checked = !!get(s, 'zoomToRoot', true);
            document.getElementById('chkShowBoundingBox').checked = !!get(s, 'showBoundingBox', true);
            document.getElementById('chkShowCenterMark').checked = !!get(s, 'showCenterMark', false);
            document.getElementById('chkShowConnectionPoints').checked = !!get(s, 'showConnectionPoints', false);
            document.getElementById('chkShowGhostlines').checked = !!get(s, 'showGhostlines', false);
            document.getElementById('chkCurved').checked = !!get(s, 'curved', false);
            document.getElementById('chkShowEdges').checked = get(s, 'showEdges', true) !== false;
            document.getElementById('numCurveMargin').value = get(s, 'curveMargin', get(s, 'curved', false) ? 0.1 : 0);
            const sel = s.selector || {};
            document.getElementById('numSelectorIn').value = get(sel, 'incomming', 1);
            document.getElementById('numSelectorOut').value = get(sel, 'outgoing', 1);
            const ns = s.nodeSpacing || {};
            document.getElementById('numNodeSpacingH').value = get(ns, 'horizontal', 20);
            document.getElementById('numNodeSpacingV').value = get(ns, 'vertical', 10);
            const cm = s.containerMargin || {};
            document.getElementById('numMarginTop').value = get(cm, 'top', 18);
            document.getElementById('numMarginRight').value = get(cm, 'right', 8);
            document.getElementById('numMarginBottom').value = get(cm, 'bottom', 8);
            document.getElementById('numMarginLeft').value = get(cm, 'left', 8);
        }

        function initializeDashboard(data = multipleLayoutsData) {
            const settings = getSettingsFromUI(data.settings);
            const dataset = { ...data, settings };
            flowdash = new flowDashboard.Dashboard(dataset);
            flowdash.initialize('#graph');
            // keep global reference up to date for tests & console
            window.flowdash = flowdash;
            updateLayoutDetails(dataset);
        }

        // Initialize with default data and set UI
        setUIFromSettings(multipleLayoutsData.settings);
        initializeDashboard(multipleLayoutsData);
        
        // Attach to window for testing and debugging
        window.flowdash = flowdash;
        window.multipleLayoutsData = multipleLayoutsData;
        window.layoutVariations = layoutVariations;
        
        // Demo functions
        window.updateDemo = function() {
            console.log('Update demo called');
            initializeDashboard(layoutVariations[currentVariationKey] || multipleLayoutsData);
        };
        
        window.resetDemo = function() {
            console.log('Reset demo called');
            currentDataIndex = 0;
            currentVariationKey = 'default';
            document.getElementById('variationSelect').value = 'default';
            setUIFromSettings(multipleLayoutsData.settings);
            initializeDashboard(multipleLayoutsData);
        };
        
        window.cycleLayouts = function() {
            const keys = Object.keys(layoutVariations);
            currentDataIndex = (currentDataIndex + 1) % keys.length;
            currentVariationKey = keys[currentDataIndex];
            document.getElementById('variationSelect').value = currentVariationKey;
            initializeDashboard(layoutVariations[currentVariationKey]);
        };
        
        window.runTests = function() {
            runDemoTests();
        };

        function updateLayoutDetails(data) {
            const detailsDiv = document.getElementById('layoutDetails');
            let html = '<div class="layout-grid">';
            
            data.nodes.forEach((node, index) => {
                const mode = node.layout.mode || 'full';
                const arrangement = node.layout.arrangement || 1;
                html += `
                    <div class="layout-card">
                        <h4>${node.label} (${node.id})</h4>
                        <p><strong>Mode:</strong> ${mode}</p>
                        <p><strong>Arrangement:</strong> ${arrangement}</p>
                        <p><strong>Description:</strong> ${getLayoutDescription(mode, arrangement)}</p>
                    </div>
                `;
            });
            
            html += '</div>';
            detailsDiv.innerHTML = html;
        }

        function getLayoutDescription(mode, arrangement) {
            const descriptions = {
                'full-1': 'Archive-focused: staging bottom-left, archive top-right, transform bottom-right',
                'full-2': 'Transform-focused: staging/archive top row, transform bottom spanning',
                'full-3': 'Staging-focused: staging left spanning, archive/transform stacked right',
                'staging-archive-4': 'Two-node horizontal: staging left, archive right',
                'staging-transform-4': 'Two-node horizontal: staging left, transform right',
                'archive-only-5': 'Single node: archive centered'
            };
            return descriptions[`${mode}-${arrangement}`] || 'Standard layout';
        }
        
        // Settings events
        document.getElementById('variationSelect').addEventListener('change', (e) => {
            currentVariationKey = e.target.value;
            initializeDashboard(layoutVariations[currentVariationKey] || multipleLayoutsData);
        });
        const immediateInputs = [
            'chkZoomToRoot','chkShowBoundingBox','chkShowCenterMark','chkShowConnectionPoints',
            'chkShowGhostlines','chkCurved','chkShowEdges','numCurveMargin','numSelectorIn','numSelectorOut',
            'numNodeSpacingH','numNodeSpacingV','numMarginTop','numMarginRight','numMarginBottom','numMarginLeft'
        ];
        immediateInputs.forEach(id => {
            const el = document.getElementById(id);
            el && el.addEventListener('change', () => {
                initializeDashboard(layoutVariations[currentVariationKey] || multipleLayoutsData);
            });
        });
        document.getElementById('rebuildBtn').addEventListener('click', () => {
            initializeDashboard(layoutVariations[currentVariationKey] || multipleLayoutsData);
        });

        // Show/Hide settings panel (hidden by default)
        const settingsPanel = document.querySelector('.settings-panel');
        const settingsBtn = document.getElementById('settingsBtn');
        const toggleSettingsVisibility = () => {
            const isOpen = settingsPanel.classList.toggle('open');
            settingsBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
            settingsBtn.textContent = isOpen ? 'Hide settings' : 'Settings';
        };
        settingsBtn.addEventListener('click', toggleSettingsVisibility);

        // Test runner
        function runDemoTests() {
            const testStatus = document.getElementById('testStatus');
            testStatus.textContent = 'Running...';
            
            // Comprehensive validation tests
            const tests = [
                testDashboardInitialization,
                testMultipleAdapterRendering,
                testAllChildNodesRendering,
                testDataStructure,
                testAdapterStructures,
                testChildPositioning,
                testTextContainment,
                testLayoutVariety,
                testZoneSystemIntegration
            ];
            
            let passed = 0;
            let total = tests.length;
            
            tests.forEach((test, index) => {
                try {
                    const result = test();
                    if (result) {
                        passed++;
                        console.log(`✅ Test ${index + 1}: ${test.name} - PASSED`);
                    } else {
                        console.log(`❌ Test ${index + 1}: ${test.name} - FAILED`);
                    }
                } catch (e) {
                    console.error(`💥 Test ${index + 1}: ${test.name} - ERROR:`, e);
                }
            });
            
            testStatus.textContent = `${passed}/${total} tests passed`;
            testStatus.className = passed === total ? 'test-pass' : 'test-fail';
            
            // Log summary
            console.log(`\n📊 Test Summary: ${passed}/${total} tests passed`);
            if (passed === total) {
                console.log('🎉 All tests passed! The multiple layouts page is working correctly.');
            } else {
                console.log('⚠️  Some tests failed. Check the console for details.');
            }
        }
        
        // Test functions
        function testDashboardInitialization() {
            return flowdash && typeof flowdash.initialize === 'function';
        }
        
        function testMultipleAdapterRendering() {
            const adapters = document.querySelectorAll('g.adapter');
            console.log(`Found ${adapters.length} adapter nodes`);
            return adapters.length > 1; // Should have multiple adapters
        }
        
        function testAllChildNodesRendering() {
            const adapters = document.querySelectorAll('g.adapter');
            let totalChildNodes = 0;
            
            adapters.forEach(adapter => {
                const childNodes = adapter.querySelectorAll('g.Node');
                totalChildNodes += childNodes.length;
            });
            
            console.log(`Found ${totalChildNodes} total child nodes across all adapters`);
            return totalChildNodes > 0;
        }
        
        function testDataStructure() {
            const currentData = window.flowdash?.data || multipleLayoutsData;
            return currentData && currentData.nodes && Array.isArray(currentData.nodes);
        }
        
        function testAdapterStructures() {
            const adapters = document.querySelectorAll('g.adapter');
            let validStructures = 0;
            
            adapters.forEach(adapter => {
                const headerBg = adapter.querySelector('rect.header-background');
                const headerText = adapter.querySelector('text.header-text');
                const mainShape = adapter.querySelector('rect.adapter.shape');
                
                if (headerBg && headerText && mainShape) {
                    validStructures++;
                }
            });
            
            console.log(`${validStructures}/${adapters.length} adapters have valid structures`);
            return validStructures === adapters.length;
        }
        
        function testChildPositioning() {
            const adapters = document.querySelectorAll('g.adapter');
            let validPositioning = 0;
            
            adapters.forEach(adapter => {
                const childNodes = adapter.querySelectorAll('g.Node');
                const innerContainer = adapter.querySelector('rect.zone-innerContainer');
                
                if (childNodes.length > 0 && innerContainer) {
                    validPositioning++;
                }
            });
            
            console.log(`${validPositioning}/${adapters.length} adapters have valid child positioning`);
            return validPositioning > 0;
        }
        
        function testTextContainment() {
            const adapters = document.querySelectorAll('g.adapter');
            let validTextContainment = 0;
            
            adapters.forEach(adapter => {
                const childRects = adapter.querySelectorAll('g.node-container rect');
                const childTexts = adapter.querySelectorAll('g.node-container text');
                
                if (childRects.length > 0 && childTexts.length > 0) {
                    validTextContainment++;
                }
            });
            
            console.log(`${validTextContainment}/${adapters.length} adapters have text elements`);
            return validTextContainment > 0;
        }
        
        function testLayoutVariety() {
            const adapters = document.querySelectorAll('g.adapter');
            const layoutSet = new Set();
            
            // This test checks if we have different arrangements
            // by examining the DOM structure variations
            adapters.forEach((adapter, index) => {
                const childNodes = adapter.querySelectorAll('g.Node');
                const layoutSignature = `${childNodes.length}`;
                layoutSet.add(layoutSignature);
            });
            
            console.log(`Found ${layoutSet.size} different layout patterns`);
            return layoutSet.size >= 1; // At least one layout pattern
        }
        
        function testZoneSystemIntegration() {
            const adapters = document.querySelectorAll('g.adapter');
            let validZones = 0;
            
            adapters.forEach(adapter => {
                const innerContainerZone = adapter.querySelector('g.zone-innerContainer');
                const zoneBorder = adapter.querySelector('rect.zone-innerContainer');
                
                if (innerContainerZone || zoneBorder) {
                    validZones++;
                }
            });
            
            console.log(`${validZones}/${adapters.length} adapters have zone system integration`);
            return validZones > 0;
        }
        
        // Auto-run tests on load
        setTimeout(runDemoTests, 3000);
        
        // Update layout details on load
        setTimeout(() => updateLayoutDetails(multipleLayoutsData), 1000);
    </script>
</body>
</html>
