<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sugiyama Layout with D3.js</title>
    <script src="libs/d3.min.js"></script>
    <script src="libs/d3-shape.min.js"></script>
    <script src="libs/d3-dag.iife.min.js"></script>
    <style>
        svg {
            border: 1px solid black;
            width: 100%;
            /* width: 700px; */
            height: 800px;
        }

        .drawing_boundary {
            stroke: gray;
            stroke-width: 0.05;
            /* fill: rgba(255, 255, 224, 0.26); */
            fill: rgba(255, 255, 224, 0.86);
        }

        .node {
            stroke: rgba(70, 131, 180, 0.5);
            stroke-width: 0.05;
            fill: steelblue;
        }

        .edge {
            stroke: #ccc;
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .marker {
            stroke: #ccc;
            stroke-width: 4px;
            fill: none;
            /* marker-end: url(#arrowhead); */
        }

        .label {
            font-size: 12px;
            text-anchor: middle;
            fill: white;
        }

        .connection-point {
            fill: rgb(70, 130, 180, 0.8);
            stroke: rgb(154, 169, 182);
            /* stroke: rgba(70, 131, 180, 0.5); */
        }
    </style>
</head>

<body>
    <h1 id="pageTitle">Title to be replaced with filename</h1>
    <script>
        // Separate block for handling the h1 content (page title and filename)
        (function () {
            // Function to get the filename from the URL
            function getFilename() {
                const path = window.location.pathname;
                const filename = path.substring(path.lastIndexOf('/') + 1);
                return filename || 'index.html'; // Default to 'index.html' if no filename
            }

            // Set the content of the h1 tag to the page title and filename
            const pageTitle = document.title;
            const filename = getFilename();
            document.getElementById('pageTitle').textContent = `${pageTitle} - ${filename}`;
        })();
    </script>

    <label for="horizontalCheckbox">Horizontal</label>
    <input type="checkbox" id="horizontalCheckbox" checked>
    <!-- Dropdown to select JSON file -->
    <label for="fileSelect">Select JSON file:</label>
    <select id="fileSelect"></select>
    <script>
        // Simulating an array of JSON filenames from the data folder
        const jsonFiles = ["dwh-1.json", "dwh-2.json", "dwh-3.json", "dwh-4.json"];

        // Populate the dropdown menu with the JSON filenames
        const fileSelect = document.getElementById("fileSelect");
        jsonFiles.forEach(filename => {
            const option = document.createElement("option");
            option.value = filename;
            option.text = filename;
            fileSelect.appendChild(option);
        });
    </script>
    <label for="curveCheckbox">Curve</label>
    <input type="checkbox" id="curveCheckbox" checked>

    <div>
        <svg id="graph" width="800" height="600"></svg>
    </div>

    <script>
        // Convert graphData to the structure required by d3.dagStratify
        function convertToStratifyData(graphData) {
            const nodesMap = new Map(graphData.nodes.map(node => [node.id, { ...node, parentIds: [] }]));

            graphData.edges.forEach(edge => {
                const targetNode = nodesMap.get(edge.targetNode);
                if (targetNode) {
                    targetNode.parentIds.push(edge.sourceNode);
                }
            });

            return Array.from(nodesMap.values());
        }

        function initializeGraphData(graphData) {
            // Initialize nodes with default width, height, and placeholder x, y attributes if not present
            graphData.nodes.forEach(node => {
                // node.x = node.x || 0;  // Placeholder x value (will be set by layout later)
                // node.y = node.y || 0;  // Placeholder y value (will be set by layout later)
                node.width = node.width || 150;  // Default width if not present
                node.height = node.height || 40;  // Default height if not present
            });
            // Initialize edges with placeholder x1, y1, x2, y2 attributes
            graphData.edges.forEach(edge => {
                // edge.x1 = edge.x1 || 0;  // Placeholder x1 value (will be set by layout later)
                // edge.y1 = edge.y1 || 0;  // Placeholder y1 value (will be set by layout later)
                // edge.x2 = edge.x2 || 0;  // Placeholder x2 value (will be set by layout later)
                // edge.y2 = edge.y2 || 0;  // Placeholder y2 value (will be set by layout later)
                edge.sourceNode = edge.source || 0;  // Placeholder source value (will be set by layout later)
                edge.targetNode = edge.target || 0;  // Placeholder source value (will be set by layout later)
            });
        }

        // Add an event listener to update the horizontal variable when the checkbox changes
        const checkbox = document.getElementById('horizontalCheckbox');
        checkbox.addEventListener('change', function () {
            horizontal = this.checked;
            drawLayout();
        });

        let horizontal = checkbox.checked; // Default to horizontal layout

        const curveCheckbox = document.getElementById('curveCheckbox');
        let isEdgeCurved = curveCheckbox.checked; // Default to horizontal layout

        curveCheckbox.addEventListener('change', function () {
            isEdgeCurved = this.checked;
            console.log("isEdgeCurved", isEdgeCurved);
            drawLayout();
        });

        let selectedFile = jsonFiles[3]; // Default to the first JSON file

        // Event listener to update selected filename from the dropdown
        fileSelect.addEventListener("change", function () {
            console.log("Old Selected file:", selectedFile);
            selectedFile = this.value;
            console.log("Selected file:", selectedFile);
            drawLayout(); // Redraw the layout when a new file is selected
        });


        function changeDirection(x, y, horizontal = true) {
            if (horizontal) {
                return { x: y, y: x };
            } else {
                return { x: x, y: y };
            }
        }

        function changePointDirection(points, horizontal) {
            if (horizontal) {
                return points.map(point => [point[1], point[0]]); // Swap x and y when horizontal is true
            }
            return points; // Return points unchanged when horizontal is false
        }


        // Set up SVG canvas
        const svg = d3.select("#graph");
        const svgWidth = +svg.attr("width");
        const svgHeight = +svg.attr("height");

        function drawLayout() {
            // start with a clean slate
            svg.selectAll("*").remove();

            const marginX = changeDirection(8, 100, horizontal).x;
            const marginY = changeDirection(50, 8, horizontal).x;


            // Load the JSON file
            d3.json(`data/${selectedFile}`).then(graphData => {
                initializeGraphData(graphData);

                console.log(graphData);
                const maxNodeHeight = Math.max(...graphData.nodes.map(node => node.height));
                const maxNodeWidth = Math.max(...graphData.nodes.map(node => node.width));
                console.log("maxHeight", maxNodeHeight, maxNodeWidth);
                const stratifyData = convertToStratifyData(graphData);

                const stratify = d3.graphStratify();
                const dag = stratify(stratifyData);

                function getNodeSize({ data }) {
                    return [
                        changeDirection(data.width + marginX, data.height + marginY, horizontal).x,
                        changeDirection(data.width + marginX, data.height + marginY, horizontal).y
                    ];
                }

                // Apply the Sugiyama layout
                const layout = d3.sugiyama()
                    .layering(d3.layeringLongestPath())
                    .decross(d3.decrossOpt())
                    // Replace d3.coordVertical with d3.coordQuad or d3.coordGreedy, coordSimplex
                    // .coord(d3.coordSimplex())
                    .coord(d3.coordQuad())
                    // .coord(d3.coordGreedy())                    
                    .nodeSize(d => getNodeSize(d));
                // .gap([marginX,marginY]);
                // .tweakFlip("diagonal");
                // .tweakShape(d => getNodeSize(d), d3.shapeRect);

                const { width, height } = layout(dag);
                console.log("layout size", width, height);
                svg.attr("viewBox", [
                    0,
                    0,
                    changeDirection(width, height, horizontal).x,
                    changeDirection(width, height, horizontal).y
                ]);


                // Debug the dag
                for (const node of dag.nodes()) {
                    console.log("node: ", node.data.id, node.x, node.y, node);
                }
                for (const { points } of dag.links()) {
                    console.log("link point:", points);
                }

                function lineGenerator1(points) {
                    const [p0, p1] = points;
                    const path = d3.path();
                    p0.x = changeDirection(p0[0], p0[1], horizontal).x;
                    p0.y = changeDirection(p0[0], p0[1], horizontal).y;
                    p1.x = changeDirection(p1[0], p1[1], horizontal).x;
                    p1.y = changeDirection(p1[0], p1[1], horizontal).y;
                    console.log("p0: ", p0);
                    console.log("p1: ", p1);


                    // Move to the starting point
                    path.moveTo(p0.x, p0.y);

                    // Control points for the cubic curve
                    const cp1x = p0.x;
                    const cp1y = (p0.y + p1.y) / 2;
                    const cp2x = p1.x;
                    const cp2y = (p0.y + p1.y) / 2;

                    // Draw a cubic curve from p0 to p1
                    path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p1.x, p1.y);

                    return path.toString();
                }

                // How to draw edges
                const curve = d3.curveBasis; //d3.curveCatmullRom; // d3.curveMonotoneY; //

                // splines.get(spline) ??
                let lineGenerator;
                if (isEdgeCurved) {
                    lineGenerator = d3.line().curve(curve);
                } 
                else {
                    lineGenerator  = d3.line();

                }

                // Draw drawing boundary
                let drawBoundary = false;
                if (drawBoundary) {
                    const drawingBoundary = svg.append("g")
                        .append("rect")
                        .attr("class", d => `drawing_boundary`)
                        .attr("x", d => 0)
                        .attr("y", d => 0)
                        .attr("width", d => changeDirection(width, height, horizontal).x)
                        .attr("height", d => changeDirection(width, height, horizontal).y);
                }


                // Draw edges
                drawEdges(svg, dag, width, height, horizontal, lineGenerator);

                // Draw nodes
                drawNodes(svg, dag, horizontal);
            })
        }



        function drawNodes(svg, dag, horizontal, showConnectionPoints = false) {
            // Draw nodes
            const node = svg.append("g")
                .selectAll(".nodecontainer")
                .data(dag.nodes())
                .enter()
                .append("g")
                .attr("class", d => `nodecontainer`)
                .attr("transform", d => `translate(${changeDirection(d.x, d.y, horizontal).x - d.data.width / 2},${changeDirection(d.x, d.y, horizontal).y - d.data.height / 2})`);

            node.append("rect")
                .attr("class", d => `node`)
                // .attr("class", d => `node s${d.data.data.state}`)
                .attr("width", d => d.data.width)
                .attr("height", d => d.data.height)
                .attr("rx", 5)
                .attr("ry", 5);

            node.append("text")
                .attr("class", "label")
                .attr("x", d => d.data.width / 2)
                .attr("y", d => d.data.height / 2 + 5)
                .text(d => d.data.label);

            if (showConnectionPoints) {
                node.each(function (d) {
                    const connectionPoints = computeConnectionPoints(d.data.width, d.data.height);
                    Object.values(connectionPoints).forEach(point => {
                        d3.select(this).append("circle")
                            .attr("class", "connection-point")
                            .attr("cx", point.x)
                            .attr("cy", point.y)
                            .attr("r", 3);
                    });
                });
            }
        }

        function computeConnectionPoints(width, height) {
            return {
                top: { x: width / 2, y: 0 },
                bottom: { x: width / 2, y: height },
                left: { x: 0, y: height / 2 },
                right: { x: width, y: height / 2 }
            };
        }

        function generateEdgePath(d, horizontal) {
            console.log("d", d);
            const sourceNode = d.source;
            const targetNode = d.target;

            const sourceConnectionPoints = computeConnectionPoints(sourceNode.data.width, sourceNode.data.height);
            const targetConnectionPoints = computeConnectionPoints(targetNode.data.width, targetNode.data.height);

            let sourcePoint, targetPoint;

            if (horizontal) {
                sourcePoint = sourceConnectionPoints.right;
                targetPoint = targetConnectionPoints.left;
            } else {
                sourcePoint = sourceConnectionPoints.bottom;
                targetPoint = targetConnectionPoints.top;
            }

            sourcePoint = [
                changeDirection(sourceNode.x, sourceNode.y, horizontal).x + sourcePoint.x - sourceNode.data.width / 2,
                changeDirection(sourceNode.x, sourceNode.y, horizontal).y + sourcePoint.y - sourceNode.data.height / 2
            ];

            targetPoint = [
                changeDirection(targetNode.x, targetNode.y, horizontal).x + targetPoint.x - targetNode.data.width / 2,
                changeDirection(targetNode.x, targetNode.y, horizontal).y + targetPoint.y - targetNode.data.height / 2
            ];

            // Calculate waypoints
            let waypoints;
            const midX = (targetPoint[0] - sourcePoint[0]) / 2;
            const midY = (targetPoint[1] - sourcePoint[1]) / 2;
            if (horizontal) {
                if (isEdgeCurved) {
                    waypoints = [
                        // // for a curve
                        [sourcePoint[0] + (midX * 0.9), sourcePoint[1] + (midY * 0.1)], // Move horizontally to half the distance
                        [sourcePoint[0] + (midX * 1.1), targetPoint[1] + (midY * 0.1)]  // Stay on x and move vertically
                    ];
                }
                else {
                    waypoints = [
                        [sourcePoint[0] + midX, sourcePoint[1]], // Move horizontally to half the distance
                        [sourcePoint[0] + midX, targetPoint[1]]  // Stay on x and move vertically
                    ];
                }
            } else {
                if (isEdgeCurved) {
                    // // for a curve
                    waypoints = [
                        [sourcePoint[0] + (midX * 0.1), sourcePoint[1] + (midY * 0.9)], // Move horizontally to half the distance
                        [targetPoint[0] - (midX * 0.1), sourcePoint[1] + (midY * 1.5)]  // Stay on x and move vertically
                    ];
                }
                else {
                    waypoints = [
                        [sourcePoint[0], sourcePoint[1] + midY], // Move horizontally to half the distance
                        [targetPoint[0], sourcePoint[1] + midY]  // Stay on x and move vertically
                    ];
                }
            }

            return [sourcePoint, ...waypoints, targetPoint];
        }

        function drawEdges(svg, dag, width, height, horizontal, lineGenerator) {

            // Define arrowhead marker
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("class", "marker")
                .attr("viewBox", "-0 -5 10 10")
                .attr("refX", changeDirection(10, 10, horizontal).x)
                .attr("refY", 0)
                .attr("orient", "auto")
                .attr("markerWidth", 4)
                .attr("markerHeight", 4)
                .attr("xoverflow", "visible")
                .append("svg:path")
                .attr("d", "M 0,-5 L 10 ,0 L 0,5");

            // Draw edges
            svg.append("g")
                .selectAll(".edge")
                .data(dag.links())
                .enter()
                .append("path")
                .attr("class", "edge")
                .attr("d", d => {
                    console.log("link points for path d: ", d);
                    console.log("link points for path: ", d.points);
                    console.log("link points for path changed: ", changePointDirection(d.points, horizontal));
                    // // return lineGenerator(d.points);
                    // return lineGenerator(changePointDirection(d.points, horizontal));

                    const points = generateEdgePath(d, horizontal);
                    console.log("points", points);
                    return lineGenerator(points);
                });
        }

        drawLayout();
    </script>
</body>

</html>