<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sugiyama Layout with D3.js</title>
    <script src="libs/d3.min.js"></script>
    <script src="libs/d3-shape.min.js"></script>
    <script src="libs/d3-dag.iife.min.js"></script>
    <script src="js/zoom.js"></script>
    <script src="js/graphData.js"></script>
    <script src="js/network.js"></script>
    <script src="js/layout.js"></script>
    <style>
        #graph {
            border: 1px solid black;
            width: 100%;
            height: 800px;
        }

        #minimap-container {
            border: 1px solid black;
        }

        #minimap {
            border: 1px solid darkblue;
            background-color: rgb(210, 255, 212);
        }
        .viewport {
            fill: none;
            stroke: rgba(255, 0, 0, 0.616);
            stroke-width: 8;
            cursor: move;
        }

        .drawing_boundary {
            stroke: gray;
            stroke-width: 0.05;
            /* fill: rgba(255, 255, 224, 0.26); */
            fill: rgba(255, 255, 224, 0.86);
        }

        .node {
            stroke: rgba(70, 131, 180, 0.5);
            stroke-width: 0.05;
            fill: steelblue;
            cursor: zoom-in;
        }

        .edge {
            stroke: #ccc;
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .marker {
            stroke: #ccc;
            stroke-width: 4px;
            fill: none;
            /* marker-end: url(#arrowhead); */
        }

        .label {
            font-size: 12px;
            text-anchor: middle;
            fill: white;
        }

        .connection-point {
            fill: rgb(70, 130, 180, 0.8);
            stroke: rgb(154, 169, 182);
            /* stroke: rgba(70, 131, 180, 0.5); */
        }
    </style>
</head>

<body>
    <h1 id="pageTitle">Title to be replaced with filename</h1>
    <script>
        // Separate block for handling the h1 content (page title and filename)
        (function () {
            // Function to get the filename from the URL
            function getFilename() {
                const path = window.location.pathname;
                const filename = path.substring(path.lastIndexOf('/') + 1);
                return filename || 'index.html'; // Default to 'index.html' if no filename
            }

            // Set the content of the h1 tag to the page title and filename
            const pageTitle = document.title;
            const filename = getFilename();
            document.getElementById('pageTitle').textContent = `${pageTitle} - ${filename}`;
        })();
    </script>

    <label for="horizontalCheckbox">Horizontal</label>
    <input type="checkbox" id="horizontalCheckbox" checked>
    <!-- Dropdown to select JSON file -->
    <label for="fileSelect">Select JSON file:</label>
    <select id="fileSelect"></select>
    <script>
        // Simulating an array of JSON filenames from the data folder
        const jsonFiles = ["dwh-1.json", "dwh-2.json", "dwh-3.json", "dwh-4.json"];

        // Populate the dropdown menu with the JSON filenames
        const fileSelect = document.getElementById("fileSelect");
        jsonFiles.forEach(filename => {
            const option = document.createElement("option");
            option.value = filename;
            option.text = filename;
            fileSelect.appendChild(option);
        });
    </script>
    <label for="curveCheckbox">Curve</label>
    <input type="checkbox" id="curveCheckbox" checked>

    <div>
        <svg id="graph"></svg>
    </div>
    <div id="zoom-controls">
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <button id="zoom-reset">Reset Zoom</button>
        <button id="zoom-random">Random Zoom</button>
        <button id="zoom-node">Zoom Node</button>
    </div>

    <div id="minimap-container">
        <svg id="minimap" width="200" height="200"></svg>
    </div>

    <script>
        // Add an event listener to update the horizontal variable when the checkbox changes
        const checkbox = document.getElementById('horizontalCheckbox');
        checkbox.addEventListener('change', function () {
            horizontal = this.checked;
            computeAndDraw(mainSvg, minimapSvg, lineGenerator);
        });

        let horizontal = checkbox.checked; // Default to horizontal layout

        const curveCheckbox = document.getElementById('curveCheckbox');
        let isEdgeCurved = curveCheckbox.checked; // Default to horizontal layout

        curveCheckbox.addEventListener('change', function () {
            isEdgeCurved = this.checked;
            lineGenerator = getLineGenerator();
            console.log("isEdgeCurved", isEdgeCurved);
            computeAndDraw(mainSvg, minimapSvg, lineGenerator);
        });

        let selectedFile = jsonFiles[3]; // Default to the first JSON file

        // Event listener to update selected filename from the dropdown
        fileSelect.addEventListener("change", function () {
                console.log("Old Selected file:", selectedFile);
                selectedFile = this.value;
                console.log("Selected file:", selectedFile);
                // computeLayout(); // Redraw the layout when a new file is selected
                fetchFileToDag(selectedFile).then(result => {
                    if (result) {
                        ({ dag, maxNodeHeight, maxNodeWidth } = result);
                        console.log("DAG:", dag);
                        console.log("Max Node Height:", maxNodeHeight);
                        console.log("Max Node Width:", maxNodeWidth);

                        // Initial layout computation and drawing
                        computeAndDraw(mainSvg, minimapSvg, lineGenerator);
                    }
                });
            });






        // Set up SVG canvas
        const mainSvg = d3.select("#graph");
        const { width: mainWidth, height: mainHeight } = getComputedDimensions(mainSvg);
        // const mainWidth = +mainSvg.attr("width");
        // const mainHeight = +mainSvg.attr("height");

        // Define the maximum dimension for the minimap
        const MAX_MINIMAP_DIMENSION = 200;

        // Calculate the aspect ratio of the main SVG
        const aspectRatio = mainWidth / mainHeight;

        // Determine the appropriate dimensions for the minimap
        let minimapWidth, minimapHeight;
        if (mainWidth >= mainHeight) {
            minimapWidth = MAX_MINIMAP_DIMENSION;
            minimapHeight = minimapWidth / aspectRatio;
        } else {
            minimapHeight = MAX_MINIMAP_DIMENSION;
            minimapWidth = minimapHeight * aspectRatio;
        }

        // Set the dimensions of the minimap SVG
        const minimapSvg = d3.select("#minimap")
            .attr("width", minimapWidth + 1)
            .attr("height", minimapHeight + 1);
        console.log("minimap", minimapWidth, minimapHeight, mainWidth, mainHeight);

        let minimapScale = Math.min(minimapWidth / mainWidth, minimapHeight / mainHeight);
        console.log("minimapScale", minimapScale);
  

        // Add viewport rectangle to the minimap
        const viewportRect = minimapSvg.append("rect")
            .attr("class", "viewport")
            .attr("width", minimapWidth)
            .attr("height", minimapHeight);


        // const minimapG = minimap.append("g");

        function drawMain(svg_canvas, dag, horizontal, width, height, lineGenerator) {
            console.log("drawMain - clean children", svg_canvas);
            // start with a clean slate
            svg_canvas.selectAll("*").remove();

            function onNodeClickFunction(event, d) {
                console.log("onClickFunction", d.data.label, d);
                zoomToNode(svg_canvas, d, dag, zoom, width, height, horizontal);
            }



            // Draw drawing boundary
            let showBoundary = true;
            drawBoundary(svg_canvas, dag, width, height, showBoundary);

            // Draw edges
            drawEdges(svg_canvas, dag, width, height, horizontal, lineGenerator);

            // Draw nodes
            drawNodes(svg_canvas, dag, horizontal, onNodeClickFunction);
        }
        function drawMinimap(svg_canvas, dag, horizontal, width, height, lineGenerator) {
            // start with a clean slate
            svg_canvas.selectAll("*").remove();


            // Draw drawing boundary
            let showBoundary = true;
            drawBoundary(svg_canvas, dag, width, height, showBoundary);

            // Draw edges
            drawEdges(svg_canvas, dag, width, height, horizontal, lineGenerator);

            // Draw nodes
            drawNodes(svg_canvas, dag, horizontal);

            // Initial update of the viewport rectangle
            // updateViewport(d3.zoomIdentity);

        }




        let lineGenerator = getLineGenerator();

        function getLineGenerator() {
            const curve = d3.curveBasis; // d3.curveCatmullRom; // d3.curveMonotoneY; //
            return isEdgeCurved ? d3.line().curve(curve) : d3.line();
        }

    // Function to update the viewport rectangle
        // function updateViewport() {
        //     console.log("updateViewport");
        //     const transform = d3.zoomTransform(mainSvg.node());
        //     console.log("transform", transform);
        //     viewportRect.attr("x", -transform.x * minimapScale)
        //         .attr("y", -transform.y * minimapScale)
        //         .attr("width", mainWidth / transform.k * minimapScale)
        //         .attr("height", mainHeight / transform.k * minimapScale);
        // }
        // Function to update the viewport rectangle based on the current zoom transform
        function adjustDimension(position, maxDimension, transformK, transformCoord) {
            let correctDimension = 0;
            let dimension = maxDimension / transformK;

            // // Adjust correctDimension if the transform.x or transform.y is less than 0
            // if (transformCoord > 0) {
            //     correctDimension = -transformCoord;
            //     console.log("correctDimension",correctDimension, transformCoord);
            // }

            // if (position > maxDimension) {
            //     correctDimension = Math.max(position + dimension - maxDimension, correctDimension);
            //     console.log("correctDimension position + dimension > maxDimension", correctDimension, position, dimension, maxDimension);
            // }

            // // Adjust correctDimension if the rectangle's edge exceeds the maxDimension
            // if (position + dimension > maxDimension) {
            //     correctDimension = Math.max(position + dimension - maxDimension, correctDimension);
            //     console.log("correctDimension position + dimension > maxDimension", correctDimension, position, dimension, maxDimension);
            // }

            // Calculate the new dimension
            return (maxDimension + correctDimension) / transformK;
        }

            function updateViewport(transform) {
                // console.log("updateViewport", horizontal,transform, width, height);

                let rectX, rectY, rectWidth, rectHeight;
                if (horizontal) {
                    rectX = Math.min( Math.max(-transform.x,0), width);
                    rectY = Math.min( Math.max(-transform.y,0), height);
                    // console.log(" border",transform.x, Math.min(-transform.x,0),transform.y, Math.min(-transform.y,0))
                    rectWidth = adjustDimension(rectX, width, transform.k, transform.x);
                    rectHeight = adjustDimension(rectY, height, transform.k, transform.y);
                    // let correctWidth = 0;
                    // if (transform.x < 0) correctWidth = Math.min(-transform.x,0);
                    // if (rectX + height / transform.k > height) correctWidth = Math.max(rectX + rectWidth - height,0)
                    // rectWidth = (height + correctWidth) / transform.k;
                    // rectHeight = (width + Math.min(-transform.y,0)) / transform.k;
                } else {
                    rectX = Math.max(-transform.x,0);
                    rectY = Math.max(-transform.y,0);
                    // rectX = -transform.x;
                    // rectY = -transform.y;
                    rectWidth = width / transform.k;
                    rectHeight = height / transform.k;
                }
                // console.log("  updateViewport   ", horizontal,transform, width, height, Math.round(rectX), Math.round(rectY), Math.round(rectWidth), Math.round(rectHeight), Math.round(rectX + rectWidth), Math.round(rectY + rectHeight));                
                // if (horizontal) {
                //     if (rectX + rectWidth > height) {
                //         console.log("    correctWidth", Math.round(rectWidth), Math.round(height - rectX), Math.round(height), Math.round(rectX));
                //         rectWidth = height - rectX;
                //     }
                //     if (rectY + rectHeight > width) {
                //         console.log("    correctHeight", Math.round(rectHeight), Math.round(width - rectY), Math.round(width), Math.round(rectY));
                //         rectHeight = Math.max(width - rectY,0);
                //     }
                //     // if (rectY + rectHeight > height) {
                //     //     console.log("correctHeight", rectHeight, height - rectY, height, rectY);
                //     //     rectHeight = height - rectY;
                //     // }
                // } else {
                //     if (rectX + rectWidth > width) {
                //         console.log("correctWidth", rectWidth, width - rectX);
                //         rectWidth = width - rectX;
                //     }
                //     if (rectY + rectHeight > height) {
                //         console.log("correctHeight", rectHeight, height - rectY);
                //         rectHeight = height - rectY;
                //     }
                // }
                // console.log("                     ", Math.round(rectX), Math.round(rectY), Math.round(rectWidth), Math.round(rectHeight), horizontal, Math.round(width), Math.round(height), Math.round(rectX + rectWidth), Math.round(rectY + rectHeight));
                
                viewportRect.attr("x", rectX)
                        .attr("y", rectY)
                        .attr("width", rectWidth)
                        .attr("height", rectHeight);
            }

        // Function to update the main SVG based on the viewport rectangle position
        function updateMainView() {
            // const x = -viewportRect.attr("x") / minimapScale;
            // const y = -viewportRect.attr("y") / minimapScale;
            // const k = 1 / minimapScale; // Adjust this if you implement zooming

            // const transform = d3.zoomIdentity.translate(x, y).scale(k);
            // mainSvg.call(zoom.transform, transform);
        }

        // Add drag behavior to the viewport rectangle
        viewportRect.call(d3.drag()
            .on("drag", (event) => {
                const newX = Math.max(0, Math.min(minimapWidth - viewportRect.attr("width"), event.x));
                const newY = Math.max(0, Math.min(minimapHeight - viewportRect.attr("height"), event.y));

                viewportRect.attr("x", newX).attr("y", newY);
                updateMainView();
            }));

        // Main execution
        let dag, zoom;
        let width, height;

        

        fetchFileToDag(selectedFile).then(result => {
            if (result) {
                ({ dag, maxNodeHeight, maxNodeWidth } = result);
                console.log("DAG:", dag);
                console.log("Max Node Height:", maxNodeHeight);
                console.log("Max Node Width:", maxNodeWidth);

                // Initial layout computation and drawing
                computeAndDraw(mainSvg, minimapSvg, lineGenerator);
            }
        });

        function computeAndDraw(svg, minimapSvg, lineGenerator) {
            ({ svg_canvas, width, height } = computeLayout(svg, minimapSvg, dag, horizontal));
            console.log("-----------------  computeAndDraw", width, height);


            zoom = initializeZoom(svg, svg_canvas, width, height, horizontal, dag, updateViewport);

            minimapScale = Math.min(minimapWidth / mainWidth, minimapHeight / mainHeight);
            console.log("minimapScale", minimapScale);
            // minimapScale = Math.min(minimapWidth / width, minimapHeight / height);
            // console.log(width, height);
            // console.log("minimapScale", minimapScale);


            drawMain(svg_canvas, dag, horizontal, width, height, lineGenerator);

            console.log("minimapScale",minimapScale)
            
            // Create minimap content group
            minimapSvg.selectAll("g").remove();

            const minimapContent = minimapSvg.insert("g", ":first-child")
            //minimapSvg.append("g");
                // .attr("transform", `scale(${minimapScale})`);

            drawMinimap(minimapContent, dag, horizontal, width, height, lineGenerator);
        }



        // // Draw your DAG on the minimap
        // function drawMinimap(dag) {
        //     // Draw nodes
        //     minimapG.selectAll(".node")
        //         .data(dag.nodes())
        //         .enter()
        //         .append("rect")
        //         .attr("class", "node")
        //         .attr("x", d => d.x * (minimapWidth / width))
        //         .attr("y", d => d.y * (minimapHeight / height))
        //         .attr("width", d => d.data.width * (minimapWidth / width))
        //         .attr("height", d => d.data.height * (minimapHeight / height))
        //         .attr("fill", "gray");

        //     // Draw edges
        //     minimapG.selectAll(".edge")
        //         .data(dag.links())
        //         .enter()
        //         .append("line")
        //         .attr("class", "edge")
        //         .attr("x1", d => d.source.x * (minimapWidth / width))
        //         .attr("y1", d => d.source.y * (minimapHeight / height))
        //         .attr("x2", d => d.target.x * (minimapWidth / width))
        //         .attr("y2", d => d.target.y * (minimapHeight / height))
        //         .attr("stroke", "black")
        //         .attr("stroke-width", 1);
        // }

        // // Function to update the minimap based on zoom transform
        // function updateMinimap(transform) {
        //     minimapG.attr("transform", `scale(${1 / transform.k}) translate(${-transform.x}, ${-transform.y})`);
        // }

        // Call drawMinimap after the main graph is drawn
        // drawMinimap(dag);

        // computeLayout();
        // drawwMain();
    </script>
</body>

</html>