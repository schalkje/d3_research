<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sugiyama Layout with D3.js</title>
    <script src="libs/d3.min.js"></script>
    <script src="libs/d3-shape.min.js"></script>
    <script src="libs/d3-dag.iife.min.js"></script>
    <script src="js/zoom.js"></script>
    <script src="js/minimap.js"></script>
    <script src="js/graphData.js"></script>
    <script src="js/drawNetwork.js"></script>
    <script src="js/layout.js"></script>
    <style>
        #graph {
            border: 1px solid black;
            width: 100%;
            height: 800px;
        }

        #minimap-container {
            border: 1px solid black;
        }

        #minimap {
            border: 1px solid darkblue;
            background-color: rgb(210, 255, 212);
        }

        .viewport {
            fill: none;
            stroke: rgba(255, 0, 0, 0.616);
            stroke-width: 8;
            cursor: move;
        }

        .drawing_boundary {
            stroke: gray;
            stroke-width: 0.05;
            /* fill: rgba(255, 255, 224, 0.26); */
            fill: rgba(255, 255, 224, 0.86);
        }

        .node {
            stroke: rgba(70, 131, 180, 0.5);
            stroke-width: 0.05;
            fill: steelblue;
            cursor: zoom-in;
        }

        .edge {
            stroke: #ccc;
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .marker {
            stroke: #ccc;
            stroke-width: 4px;
            fill: none;
            /* marker-end: url(#arrowhead); */
        }

        .label {
            font-size: 12px;
            text-anchor: middle;
            fill: white;
        }

        .connection-point {
            fill: rgb(70, 130, 180, 0.8);
            stroke: rgb(154, 169, 182);
            /* stroke: rgba(70, 131, 180, 0.5); */
        }
    </style>
</head>

<body>
    <h1 id="pageTitle">Title to be replaced with filename</h1>
    <script>
        // Separate block for handling the h1 content (page title and filename)
        (function () {
            // Function to get the filename from the URL
            function getFilename() {
                const path = window.location.pathname;
                const filename = path.substring(path.lastIndexOf('/') + 1);
                return filename || 'index.html'; // Default to 'index.html' if no filename
            }

            // Set the content of the h1 tag to the page title and filename
            const pageTitle = document.title;
            const filename = getFilename();
            document.getElementById('pageTitle').textContent = `${pageTitle} - ${filename}`;
        })();
    </script>

    <label for="horizontalCheckbox">Horizontal</label>
    <input type="checkbox" id="horizontalCheckbox">
    <!-- Dropdown to select JSON file -->
    <label for="fileSelect">Select JSON file:</label>
    <select id="fileSelect"></select>
    <script>
        // Simulating an array of JSON filenames from the data folder
        const jsonFiles = ["dwh-1.json", "dwh-2.json", "dwh-3.json", "dwh-4.json", "dwh-5.json", "dwh-6.json", "dwh-7a.json", "dwh-7b.json", "dwh-7.json", "dwh-8.json"];

        // Populate the dropdown menu with the JSON filenames
        const fileSelect = document.getElementById("fileSelect");
        jsonFiles.forEach(filename => {
            const option = document.createElement("option");
            option.value = filename;
            option.text = filename;
            fileSelect.appendChild(option);
        });
    </script>
    <label for="curveCheckbox">Curve</label>
    <input type="checkbox" id="curveCheckbox" checked>

    <div>
        <svg id="graph"></svg>
    </div>
    <div id="zoom-controls">
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <button id="zoom-reset">Reset Zoom</button>
        <button id="zoom-random">Random Zoom</button>
        <button id="zoom-node">Zoom Node</button>
    </div>

    <div id="minimap-container">
        <svg id="minimap" width="200" height="200"></svg>
    </div>

    <script>
        // Add an event listener to update the horizontal variable when the checkbox changes
        const checkbox = document.getElementById('horizontalCheckbox');
        checkbox.addEventListener('change', function () {
            horizontal = this.checked;
            computeAndDraw(mainSvg, lineGenerator);
        });

        let horizontal = checkbox.checked; // Default to horizontal layout

        const curveCheckbox = document.getElementById('curveCheckbox');
        let isEdgeCurved = curveCheckbox.checked; // Default to horizontal layout

        curveCheckbox.addEventListener('change', function () {
            isEdgeCurved = this.checked;
            lineGenerator = getLineGenerator();
            console.log("isEdgeCurved", isEdgeCurved);
            computeAndDraw(mainSvg, lineGenerator);
        });

        let selectedFile = jsonFiles[1]; // Default to the first JSON file

        // Event listener to update selected filename from the dropdown
        fileSelect.addEventListener("change", function () {
            console.log("Old Selected file:", selectedFile);
            selectedFile = this.value;
            console.log("Selected file:", selectedFile);
            // computeLayout(); // Redraw the layout when a new file is selected
            fetchFileToDag(selectedFile).then(result => {
                if (result) {
                    ({ dag, maxNodeHeight, maxNodeWidth } = result);
                    console.log("DAG:", dag);
                    console.log("Max Node Height:", maxNodeHeight);
                    console.log("Max Node Width:", maxNodeWidth);

                    // Initial layout computation and drawing
                    computeAndDraw(mainSvg, lineGenerator);
                }
            });
        });


    </script>





    <script>
        // Set up SVG canvas
        const mainSvg = d3.select("#graph");
        const { width: mainWidth, height: mainHeight } = getComputedDimensions(mainSvg);

        const minimap = setupMinimap({x:mainWidth, y:mainHeight}, updateMainView);

        function onNodeClickFunction(event, d) {
            console.log("onClickFunction", d.data.label, d);
            zoomToNode(svg_canvas, d, dag, zoom, width, height, horizontal);
        }
        function drawMain(svg_canvas, dag, horizontal, width, height, lineGenerator) {
            console.log("drawMain - clean children", svg_canvas);
            // start with a clean slate
            svg_canvas.selectAll("*").remove();




            // Draw drawing boundary
            let showBoundary = true;
            drawBoundary(svg_canvas, dag, width, height, showBoundary);

            // Draw edges
            drawEdges(svg_canvas, dag, width, height, horizontal, lineGenerator);

            // Draw nodes
            drawNodes(svg_canvas, dag, horizontal, onNodeClickFunction);
        }
        function drawMinimap(svg_canvas, dag, horizontal, width, height, lineGenerator) {
            // start with a clean slate
            svg_canvas.selectAll("*").remove();


            // Draw drawing boundary
            let showBoundary = true;
            drawBoundary(svg_canvas, dag, width, height, showBoundary);

            // Draw edges
            drawEdges(svg_canvas, dag, width, height, horizontal, lineGenerator);

            // Draw nodes
            drawNodes(svg_canvas, dag, horizontal, onNodeClickFunction, false, true);

            // Initial update of the viewport rectangle
            updateViewport(d3.zoomIdentity);

        }




        let lineGenerator = getLineGenerator();

        function getLineGenerator() {
            const curve = d3.curveBasis; // d3.curveCatmullRom; // d3.curveMonotoneY; //
            return isEdgeCurved ? d3.line().curve(curve) : d3.line();
        }

        // Function to update the viewport rectangle based on the current zoom transform
        function adjustDimension(position, maxDimension, transformK, transformCoord) {
            let correctDimension = 0;
            let dimension = maxDimension / transformK;

            // // Adjust correctDimension if the transform.x or transform.y is less than 0
            // if (transformCoord > 0) {
            //     correctDimension = -transformCoord;
            //     console.log("correctDimension",correctDimension, transformCoord);
            // }

            // if (position > maxDimension) {
            //     correctDimension = Math.max(position + dimension - maxDimension, correctDimension);
            //     console.log("correctDimension position + dimension > maxDimension", correctDimension, position, dimension, maxDimension);
            // }

            // // Adjust correctDimension if the rectangle's edge exceeds the maxDimension
            // if (position + dimension > maxDimension) {
            //     correctDimension = Math.max(position + dimension - maxDimension, correctDimension);
            //     console.log("correctDimension position + dimension > maxDimension", correctDimension, position, dimension, maxDimension);
            // }

            // Calculate the new dimension
            // return (maxDimension + correctDimension) / transformK;
            return dimension * transformK;
        }

        function roundToTwoDecimals(num) {
            return Math.round(num * 100) / 100;
        }

        function updateViewport(transform) {
            // compute the vertical border next to and above the canvas
            const whiteSpaceY = (width * (mainHeight / mainWidth) - height) * 0.5;
            const whiteSpaceX = (height * (mainWidth / mainHeight) - width) * 0.5;

            const isHorizontalCanvas = width / height > mainWidth / mainHeight;

            const widthScale = mainWidth / width;
            const heightScale = mainHeight / height;

            let rectX, rectY, rectWidth, rectHeight;
            rectX = -transform.x / transform.k
            rectY = -transform.y / transform.k;
            rectWidth = mainWidth / transform.k / widthScale;
            rectHeight = mainHeight / transform.k / heightScale;

            if (isHorizontalCanvas) {
                rectY -= whiteSpaceY / transform.k;
                rectHeight += whiteSpaceY / transform.k * 2;
            }
            else {
                rectX -= whiteSpaceX / transform.k;
                rectWidth += whiteSpaceX / transform.k * 2;
            }

            minimap.viewport.attr("x", rectX)
                .attr("y", rectY)
                .attr("width", rectWidth)
                .attr("height", rectHeight);
        }

        // Function to update the main SVG based on the viewport rectangle position
        let initialX, initialY;

        // Function to update the main SVG based on the viewport rectangle position
        function updateMainView(drag) {
            console.log("updateMainView", drag, minimap.scale);
            const x = (-drag.x) / minimap.scale;
            const y = (-drag.y) / minimap.scale;

            // Maintain the current scale
            const currentTransform = d3.zoomTransform(svg_canvas.node());
            const k = currentTransform.k;
            console.log("              ", x, y, k, currentTransform);

            const transformOut = d3.zoomIdentity.translate(x, y).scale(k);
            mainSvg.call(zoom.transform, transformOut);
        }


        // Main execution
        let dag, zoom;
        let width, height;



        fetchFileToDag(selectedFile).then(result => {
            if (result) {
                ({ dag, maxNodeHeight, maxNodeWidth } = result);
                console.log("DAG:", dag);
                console.log("Max Node Height:", maxNodeHeight);
                console.log("Max Node Width:", maxNodeWidth);

                // Initial layout computation and drawing
                computeAndDraw(mainSvg, lineGenerator);
            }
        });

        function computeAndDraw(svg, lineGenerator) {
            ({ svg_canvas, width, height } = computeLayout(svg, minimap.svg, dag, horizontal));
            console.log("-----------------  computeAndDraw", width, height);


            zoom = initializeZoom(svg, svg_canvas, width, height, horizontal, dag, updateViewport);

            drawMain(svg_canvas, dag, horizontal, width, height, lineGenerator);

            console.log("minimapScale", minimap.scale)

            // Create minimap content group
            minimap.svg.selectAll("g").remove();

            const minimapContent = minimap.svg.insert("g", ":first-child")
            //minimapSvg.append("g");
            // .attr("transform", `scale(${minimapScale})`);

            drawMinimap(minimapContent, dag, horizontal, width, height, lineGenerator);
        }

    </script>
</body>

</html>